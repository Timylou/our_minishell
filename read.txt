/*
 * Cambio:
 *     1. En structs.h
 *
 * Motivo del cambio:
 *     1. La estructura antigua `t_shell` no contenía los campos necesarios
 *        para gestionar correctamente la ejecución de los procesos hijos.
 *     2. En particular, faltaba un array de PID para los procesos con fork(),
 *        lo que dificultaba el manejo correcto de señales y del estado de salida.
 *     3. Para poder hacer waitpid() a todos los hijos y actualizar $?,
 *        era necesario almacenar esta información en la estructura principal.
 *
 * Cambios realizados:
 *     1. Se añadió el campo `pid_t *pids` a la estructura `t_shell`:
 *         - Sirve para almacenar los PID de los procesos hijos ejecutados mediante fork().
 *     2. Se añadió el campo `int nb_cmds` a la estructura `t_shell`:
 *         - Permite saber cuántos procesos se lanzaron, para hacer correctamente el bucle con waitpid().
 *     3. Gracias a estos cambios ahora se puede:
 *         - Esperar correctamente a todos los procesos hijos.
 *         - Detectar señales como SIGINT y SIGQUIT.
 *         - Actualizar correctamente el valor de $? como lo hace Bash.
 */


 * Cambio:
 *     1. En exec.c
 *
 * Motivo del cambio:
 *     1. La implementación anterior no guardaba los PID de los hijos,
 *        por lo tanto no se podía hacer waitpid() correctamente.
 *     2. Esto impedía detectar si los procesos terminaban por señales como SIGINT o SIGQUIT.
 *     3. Además, el valor de salida ($?) no se actualizaba correctamente.
 *     4. Bash espera a todos los hijos y refleja su estado en $?, por lo tanto debemos hacer lo mismo.
 *
 * Cambios realizados:
 *     1. Se agregó un array shell->pids para almacenar los PID de cada proceso hijo.
 *     2. Separé la lógica en tres funciones auxiliares:
 *         - ft_count_cmds: cuenta los comandos a ejecutar.
 *         - ft_init_process: hace fork() y lanza los procesos.
 *         - ft_wait_and_set_exit_status: hace waitpid() por cada hijo y actualiza exit_status.
 *     3. La función ft_process ahora solo coordina el flujo general.
 *         Llama a ft_init_process, que contiene el bucle principal.
 *         Esto lo hice porque, de lo contrario, la función superaba las 25 líneas permitidas.
 *     4. Esta nueva estructura permite detectar correctamente interrupciones (Ctrl+C, Ctrl+\)
 *         y actualizar $? igual que lo hace Bash.


