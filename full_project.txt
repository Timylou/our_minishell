# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/05/01 07:16:59 by brturcio          #+#    #+#              #
#    Updated: 2025/05/24 11:10:43 by brturcio         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

NAME		:= minishell
CC			:= cc
CFLAGS		:= -Wall -Wextra -Werror -g


DIR_SRCS		:= srcs
DIR_OBJS		:= objs
DIR_LIBFT		:= libft

SRCS			:=	$(DIR_SRCS)/banner.c $(DIR_SRCS)/main.c $(DIR_SRCS)/free.c	\
					$(DIR_SRCS)/builtins/builtins.c $(DIR_SRCS)/builtins/echo.c	\
					$(DIR_SRCS)/builtins/env_utils.c $(DIR_SRCS)/builtins/env.c	\
					$(DIR_SRCS)/builtins/pwd.c $(DIR_SRCS)/builtins/cd.c		\
					$(DIR_SRCS)/builtins/export.c $(DIR_SRCS)/builtins/export_utils.c\
					$(DIR_SRCS)/builtins/export_utils2.c \
					$(DIR_SRCS)/builtins/cd_path.c $(DIR_SRCS)/builtins/exit.c	\
					$(DIR_SRCS)/structs/env.c $(DIR_SRCS)/structs/env_utils.c\
					$(DIR_SRCS)/structs/shell.c		\
					$(DIR_SRCS)/structs/history.c								\
					$(DIR_SRCS)/parsing/parse.c $(DIR_SRCS)/parsing/token.c		\
					$(DIR_SRCS)/parsing/file.c $(DIR_SRCS)/parsing/heredoc.c	\
					$(DIR_SRCS)/parsing/sort_token.c $(DIR_SRCS)/parsing/cmd.c	\
					$(DIR_SRCS)/exec/exec.c										\
					$(DIR_SRCS)/readline/readline.c $(DIR_SRCS)/readline/switch.c\
					$(DIR_SRCS)/signals/signal.c


					#$(wildcard $(DIR_SRCS)/builtins/*.c)
					#$(wildcard $(DIR_SRCS)/*.c)
					#$(wildcard $(DIR_SRCS)/structs/*.c)
					# Add other folders below if needed (e.g., parser, utils, etc.)
					# SRCS := $(shell find $(DIR_SRCS) -type f -name "*.c")

LIBS := -lreadline -lhistory -lncurses


# Object files: convert each source file path into a corresponding .o path in objs/
# For example: srcs/builtins/echo.c → objs/builtins/echo.o
OBJS 			:= $(patsubst %.c, $(DIR_OBJS)/%.o, $(subst $(DIR_SRCS)/,,$(SRCS)))
LIBFT			:= $(DIR_LIBFT)/libft.a

# Include paths for headers (local and from libft)
INCLUDES		:= -I$(DIR_LIBFT)/inc -Iinclude

all : $(LIBFT) $(NAME)

# Compile each .c file into a .o file
# Also creates necessary subdirectories inside objs/ automatically
$(DIR_OBJS)/%.o: $(DIR_SRCS)/%.c
	@mkdir -p $(dir $@)
	@$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

# Link all object files with libft to produce the final executable
$(NAME): $(OBJS)
	@$(CC) $(CFLAGS) $(OBJS) $(LIBFT) -o $@ $(LIBS)
	@echo "✅ Compilation completed: $(NAME)"

# Build libft only if libft.a does not already exist
$(LIBFT):
	@if [ ! -f $@ ] ; then \
		$(MAKE) -s -C $(DIR_LIBFT); \
	fi

clean :
	@rm -rf $(DIR_OBJS)
	@$(MAKE) -s -C $(DIR_LIBFT) clean
	@echo "✅ clean done."

fclean : clean
	@rm -f $(NAME)
	@$(MAKE) -s -C $(DIR_LIBFT) fclean
	@echo "✅ fclean done."

re : fclean all

norm	:
	@norminette include/
	@norminette $(SRCS)

.PHONY : all clean fclean re libft
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cmd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 10:56:04 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/06 15:18:52 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	**ft_get_path(t_shell *shell)
{
	char	**path;
	t_env	*env;

	env = ft_search_env("PATH", shell);
	if (env)
		path = ft_split(env->data + 5, ':');
	else
	{
		path = malloc(sizeof(char *));
		path[0] = NULL;
	}
	return (path);
}

static int	ft_search_path(char *cmd_name, char **args, char **path)
{
	int		i;
	char	*arg;
	char	*cmd_path;

	i = 0;
	while (path[i])
	{
		arg = ft_strjoin("/", cmd_name);
		cmd_path = ft_strjoin(path[i], arg);
		free(arg);
		if (!access(cmd_path, X_OK))
		{
			ft_free_array(path);
			free(cmd_name);
			args[0] = cmd_path;
			return (1);
		}
		free(cmd_path);
		i++;
	}
	ft_free_array(path);
	return (0);
}

static char	**ft_access(char **args, t_shell *shell)
{
	int		i;
	char	*cmd_name;
	char	**path;

	if (ft_is_builtin(args[0]))
		return (args);
	path = ft_get_path(shell);
	cmd_name = args[0];
	if (ft_search_path(cmd_name, args, path))
		return (args);
	if (!access(cmd_name, X_OK))
		return (args);
	perror(cmd_name);
	i = 0;
	while (args[i])
	{
		free(args[i]);
		args[i] = NULL;
		i++;
	}
	free(args);
	args = NULL;
	return (NULL);
}

static int	nb_word(t_token *token)
{
	int	i;

	i = 0;
	while (token && token->type != TOKEN_PIPE)
	{
		if (token->type == TOKEN_WORD)
			i++;
		token = token->next;
	}
	return (i);
}

int	ft_open_cmd(t_token	**token, t_cmd *cmd, t_shell *shell)
{
	int		nb_args;
	int		i;
	int		success;
	char	**args;

	nb_args = nb_word(*token);
	args = malloc(sizeof(char *) * (nb_args + 1));
	if (!args)
		return (0);
	success = 1;
	i = 0;
	while (i < nb_args)
	{
		if ((*token)->type == TOKEN_WORD)
		{
			args[i] = ft_strdup((*token)->value);
			if (!args[i++])
				success = 0;
		}
		if (i != nb_args)
			*token = (*token)->next;
	}
	args[i] = NULL;
	cmd->args = ft_access(args, shell);
	return (success);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 10:18:43 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/07 10:38:14 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	*ft_get_next_word(char *line, int *i)
{
	int		begin_word;
	int		end_word;
	int		j;
	char	*word;

	while (ft_isspace(line[*i]))
		*i += 1;
	begin_word = *i;
	while (line[*i] && !ft_isspace(line[*i]))
		*i += 1;
	end_word = (*i)++;
	word = malloc(sizeof(char) * (end_word - begin_word) + 1);
	if (!word)
		return (NULL);
	j = 0;
	while (j < end_word - begin_word)
	{
		word[j] = line[begin_word + j];
		j++;
	}
	word[j] = '\0';
	return (word);
}

static t_token	*ft_add_token(char *line, int *i, t_token_type t, t_shell *shl)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		ft_error("token malloc error", EXIT_MALLOC, shl);
	token->type = t;
	if (token->type == TOKEN_REDIR_IN || token->type == TOKEN_REDIR_OUT)
		*i += 1;
	if (token->type == TOKEN_HEREDOC || token->type == TOKEN_REDIR_APPEND)
		*i += 2;
	token->next = NULL;
	token->value = ft_get_next_word(line, i);
	if (!token->value)
	{
		free(token);
		ft_error("token value malloc error", EXIT_MALLOC, shl);
	}
	if (!token->value[0])
	{
		free(token->value);
		free(token);
		return (NULL);
	}
	return (token);
}

static t_token	*ft_add_token_pipe(int *i, t_shell *shell)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		ft_error("token malloc error", EXIT_MALLOC, shell);
	token->type = TOKEN_PIPE;
	token->next = NULL;
	token->value = NULL;
	*i += 1;
	return (token);
}

static void	ft_switch_token(char *line, int *i, t_token **token, t_shell *shell)
{
	t_token	*aux_token;
	t_token	*cur_token;

	if (line[*i] == '<' && line[*i + 1] == '<')
		cur_token = ft_add_token(line, i, TOKEN_HEREDOC, shell);
	else if (line[*i] == '<')
		cur_token = ft_add_token(line, i, TOKEN_REDIR_IN, shell);
	else if (line[*i] == '>' && line[*i + 1] == '>')
		cur_token = ft_add_token(line, i, TOKEN_REDIR_APPEND, shell);
	else if (line[*i] == '>')
		cur_token = ft_add_token(line, i, TOKEN_REDIR_OUT, shell);
	else if (line[*i] == '|')
		cur_token = ft_add_token_pipe(i, shell);
	else
		cur_token = ft_add_token(line, i, TOKEN_WORD, shell);
	if (*token)
	{
		aux_token = *token;
		while (aux_token->next)
			aux_token = aux_token->next;
		aux_token->next = cur_token;
	}
	else
		*token = cur_token;
}

t_token	*ft_tokeniser(char *line, t_shell *shell)
{
	t_token	*token;
	int		len;
	int		i;

	token = NULL;
	len = ft_strlen(line);
	i = 0;
	while (i < len && ft_isspace(line[i]))
		i++;
	while (i < len)
	{
		ft_switch_token(line, &i, &token, shell);
		while (i < len && ft_isspace(line[i]))
			i++;
	}
	return (token);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   sort_token.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 12:52:59 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/07 10:28:31 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	ft_token_info(t_token *tkn, int tab_info[3])
{
	int	i;

	tab_info[1] = 0;
	tab_info[2] = 0;
	i = 0;
	while (tkn && tkn->type != TOKEN_PIPE)
	{
		if (tkn->type == TOKEN_REDIR_IN || tkn->type == TOKEN_HEREDOC
			|| tkn->type == TOKEN_REDIR_OUT || tkn->type == TOKEN_REDIR_APPEND)
			tab_info[1] += 1;
		if (tkn->type == TOKEN_WORD)
			tab_info[2] += 1;
		i++;
		tkn = tkn->next;
	}
	tab_info[0] = i;
}

static void	ft_place_token(t_token *token, t_token **tab_token, int tab_info[3])
{
	int	first;

	if (token->type == TOKEN_REDIR_IN || token->type == TOKEN_HEREDOC
		|| token->type == TOKEN_REDIR_OUT || token->type == TOKEN_REDIR_APPEND)
		first = 0;
	else
		first = tab_info[1];
	while (tab_token[first])
		first++;
	tab_token[first] = token;
}

static void	ft_link_token(t_token **tab_token, int len, t_token *last_token)
{
	t_token	*cur_token;
	int		i;

	if (len == 0)
		return ;
	i = 0;
	while (i < len - 1)
	{
		cur_token = tab_token[i];
		cur_token->next = tab_token[++i];
	}
	cur_token = tab_token[i];
	cur_token->next = last_token;
}

t_token	*ft_sort_token(t_token *token)
{
	t_token	**tab_token;
	int		tab_info[3];
	int		len;

	if (!token)
		return (NULL);
	ft_token_info(token, tab_info);
	if (tab_info[0] == 0)
		return (token);
	tab_token = malloc(sizeof(t_token *) * tab_info[0]);
	len = tab_info[0];
	while (len-- > 0)
		tab_token[len] = NULL;
	while (token && token->type != TOKEN_PIPE)
	{
		ft_place_token(token, tab_token, tab_info);
		token = token->next;
	}
	if (token && token->type == TOKEN_PIPE)
		token->next = ft_sort_token(token->next);
	ft_link_token(tab_token, tab_info[0], token);
	token = tab_token[0];
	free(tab_token);
	return (token);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   file.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 23:15:55 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/06 22:13:17 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_open_infile(char *filename, t_cmd *cmd)
{
	if (cmd->in > 0 && cmd->in != STDIN_FILENO)
		close(cmd->in);
	cmd->in = open(filename, O_RDONLY);
	if (cmd->in < 0)
	{
		perror(filename);
		return (0);
	}
	return (1);
}

int	ft_open_outfile(char *filename, t_cmd *cmd, t_token_type type)
{
	if (cmd->out > 0 && cmd->out != STDOUT_FILENO)
		close(cmd->out);
	if (type == TOKEN_REDIR_OUT)
		cmd->out = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else
		cmd->out = open(filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
	if (cmd->out < 0)
	{
		perror(filename);
		return (0);
	}
	return (1);
}

void	ft_open_pipe(t_cmd *cmd, t_shell *shell)
{
	t_cmd	*new_cmd;
	int		end[2];

	new_cmd = ft_init_cmd();
	if (!new_cmd)
		ft_error("malloc cmd error", EXIT_MALLOC, shell);
	if (pipe(end) < 0)
		ft_error("pipe error", EXIT_FD, shell);
	if (cmd->out == STDOUT_FILENO)
		cmd->out = end[1];
	else
		close(end[1]);
	new_cmd->in = end[0];
	cmd->next = new_cmd;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 22:47:10 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/09 12:27:13 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_cmd	*ft_init_cmd(void)
{
	t_cmd	*cmd;

	cmd = malloc(sizeof(t_cmd));
	if (!cmd)
		return (NULL);
	cmd->args = NULL;
	cmd->in = STDIN_FILENO;
	cmd->out = STDOUT_FILENO;
	cmd->next = NULL;
	return (cmd);
}

static int	ft_manage_token(t_token **tkn, t_cmd *cmd, t_token *a, t_shell *s)
{
	int	success;

	success = 1;
	if ((*tkn)->type == TOKEN_REDIR_IN)
		success = ft_open_infile((*tkn)->value, cmd);
	else if ((*tkn)->type == TOKEN_REDIR_OUT
		|| (*tkn)->type == TOKEN_REDIR_APPEND)
		success = ft_open_outfile((*tkn)->value, cmd, (*tkn)->type);
	else if ((*tkn)->type == TOKEN_WORD)
		success = ft_open_cmd(tkn, cmd, s);
	else if ((*tkn)->type == TOKEN_PIPE)
		ft_open_pipe(cmd, s);
	else if ((*tkn)->type == TOKEN_HEREDOC)
		ft_heredoc((*tkn)->value, cmd, a, s);
	return (success);
}

static void	ft_free_token(t_token *token)
{
	t_token	*next_token;

	while (token)
	{
		next_token = token->next;
		free(token->value);
		free(token);
		token = next_token;
	}
}

void	ft_parse(char *line, t_shell *shell)
{
	t_token	*token;
	t_token	*all_token;
	t_cmd	*cmd;

	all_token = ft_tokeniser(line, shell);
	token = ft_sort_token(all_token);
	all_token = token;
	cmd = ft_init_cmd();
	if (!cmd)
		ft_error("cmd malloc error", EXIT_MALLOC, shell);
	shell->cmds = cmd;
	while (token)
	{
		if (!ft_manage_token(&token, cmd, all_token, shell))
			break ;
		if (token->type == TOKEN_PIPE)
			cmd = cmd->next;
		if (token)
			token = token->next;
	}
	ft_free_token(all_token);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/12/24 17:23:25 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/07 13:11:07 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	ft_free_shell_and_token(t_token *all_token, t_shell *shell)
{
	t_token	*next_token;

	while (all_token)
	{
		next_token = all_token->next;
		free(all_token->value);
		free(all_token);
		all_token = next_token;
	}
	ft_free_shell(shell);
}

static char	*ft_read_line(int fd)
{
	char	buffer[2];
	char	*line;
	char	*temp;
	int		res;

	line = malloc(sizeof(char));
	if (!line)
		return (NULL);
	line[0] = 0;
	buffer[1] = 0;
	buffer[0] = 0;
	while (buffer[0] != '\n')
	{
		res = read(fd, buffer, 1);
		if (res <= 0 || res == EOF)
		{
			free(line);
			return (NULL);
		}
		temp = line;
		line = ft_strjoin(line, buffer);
		free(temp);
	}
	return (line);
}

static void	ft_read_stdin(int end[2], char *limiter, t_token *a, t_shell *shl)
{
	char	*line;
	int		len_line;

	close(end[0]);
	write(1, "here_doc> ", 10);
	line = ft_read_line(STDIN_FILENO);
	while (line)
	{
		len_line = ft_strlen(line) - 1;
		if (!ft_strncmp(line, limiter, len_line))
		{
			free(line);
			close(end[1]);
			ft_free_shell_and_token(a, shl);
			exit(EXIT_SUCCESS);
		}
		write(end[1], line, len_line + 1);
		write(1, "here_doc> ", 10);
		free(line);
		line = ft_read_line(STDIN_FILENO);
	}
	close(end[1]);
	ft_free_shell_and_token(a, shl);
	exit(EXIT_FAILURE);
}

void	ft_heredoc(char *limiter, t_cmd *cmd, t_token *alltkn, t_shell *shell)
{
	pid_t	pid;
	int		end[2];

	if (pipe(end) < 0)
		ft_error("Cannot open pipe in heredoc", EXIT_FD, shell);
	pid = fork();
	if (pid < 0)
		ft_error("fork in heredoc failed", EXIT_FD, shell);
	if (!pid)
		ft_read_stdin(end, limiter, alltkn, shell);
	close(end[1]);
	waitpid(pid, NULL, 0);
	cmd->in = end[0];
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 14:45:12 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/27 15:00:23 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_free_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		array[i] = NULL;
		i++;
	}
	free(array);
	array = NULL;
}

void	ft_free_cmds(t_cmd *cmds)
{
	t_cmd	*next_cmd;

	next_cmd = NULL;
	while (cmds)
	{
		next_cmd = cmds->next;
		if (cmds->args)
			ft_free_array(cmds->args);
		if (cmds->in >= 0 && cmds->in != STDIN_FILENO)
			close(cmds->in);
		if (cmds->out >= 0 && cmds->out != STDOUT_FILENO)
			close(cmds->out);
		free(cmds);
		cmds = next_cmd;
	}
}

void	ft_free_env(t_env *env)
{
	t_env	*next_env;

	next_env = NULL;
	while (env)
	{
		next_env = env->next;
		free(env->data);
		free(env->var);
		free(env->value);
		free(env);
		env = next_env;
	}
}

void	ft_error(char *msg, int exit_code, t_shell *shell)
{
	if (!shell)
		exit(EXIT_FAILURE);
	perror(msg);
	ft_free_shell(shell);
	exit(exit_code);
}

void	ft_free_shell(t_shell *shell)
{
	if (shell)
	{
		if (shell->cmds)
			ft_free_cmds(shell->cmds);
		if (shell->env)
			ft_free_env(shell->env);
		if (shell->history)
			ft_free_history(shell->history);
		rl_clear_history();
		free(shell);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/22 10:32:34 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/27 13:23:20 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_sigint_handler(int signal)
{
	g_signal = signal;
	write(STDOUT_FILENO, "\n", 1);
	rl_on_new_line();
	rl_replace_line("", 0);
	rl_redisplay();

}

void	ft_signals_control_main(void)
{
	signal(SIGINT, ft_sigint_handler);
	signal(SIGQUIT, SIG_IGN);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 08:26:31 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/27 15:48:01 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

volatile sig_atomic_t	g_signal = 0;

// void	ft_print_prompt(t_shell *shell)
// {
// 	t_env	*logname;
// 	t_env	*hostname;
// 	t_env	*pwd;

// 	if (!isatty(STDIN_FILENO))
// 		return ;
// 	logname = ft_search_env("LOGNAME", shell);
// 	hostname = ft_search_env("NAME", shell);
// 	pwd = ft_search_env("PWD", shell);
// 	if (logname)
// 		ft_printf(HGRN"%s"RST, logname->data + 8);
// 	if (hostname)
// 		ft_printf(CYAN"@%s"RST, hostname->data + 5);
// 	if (logname || hostname)
// 		write(1, ":", 1);
// 	if (pwd)
// 		ft_printf(HMAG"%s"RST, pwd->data + 4);
// 	write(1, "$\t", 2);
// }

// static void	ft_handle_line(char *line, char **env, t_shell *shell)
// {
// 	ft_init_history(line, shell);
// 	ft_parse(line, shell);
// 	ft_process(env, shell);
// 	while (wait(NULL) != -1)
// 		;
// }

// static int	ft_check_signal(char *line)
// {
// 	if (g_signal == SIGINT)
// 	{
// 		g_signal = 0;
// 		if (line)
// 			free(line);
// 		return (1);
// 	}
// 	return (0);
// }

// int	main(int argc, char **argv, char **env)
// {
// 	t_shell	*shell;
// 	char	*line;

// 	(void) argc;
// 	(void) argv;
// 	printbanner();
// 	shell = init_shell(env);
// 	ft_signals_control_main();
// 	while (shell)
// 	{
// 		g_signal = 0;
// 		ft_print_prompt(shell);
// 		line = get_next_line(STDIN_FILENO);
// 		if (ft_check_signal(line))
// 			continue ;
// 		if (!line)
// 			break ;
// 		ft_handle_line(line, env, shell);
// 		free(line);
// 	}
// 	ft_free_shell(shell);
// 	if (isatty(STDIN_FILENO))
// 		ft_printf(YELLOW"\nSEE YOU SOON !\n"RST);
// 	return (EXIT_SUCCESS);
// }


char	*ft_print_prompt(t_shell *shell)
{
	char	*prompt;
	t_env	*logname;
	char	*tmp;
	char	pwd[BUFSIZ];

	if (!getcwd(pwd, sizeof(pwd)))
		return (ft_strdup(HGRN"minishell $> "RST));
	logname = ft_find_env(shell, "LOGNAME");
	if (!logname)
		logname->value = "user";
	prompt = ft_strjoin(HGRN, logname->value);
	prompt = ft_strjoin_free(prompt, ":");
	prompt = ft_strjoin_free(prompt, RST);
	tmp = ft_strjoin(prompt, HMAG);
	free(prompt);
	prompt = tmp;
	prompt = ft_strjoin_free(prompt, pwd);
	prompt = ft_strjoin_free(prompt, RST);
	prompt = ft_strjoin_free(prompt, "$> ");
	return (prompt);
}

static void	ft_handle_line(char *line, char **env, t_shell *shell)
{
	add_history(line);
	ft_parse(line, shell);
	ft_process(env, shell);
	while (wait(NULL) != -1)
		;
}

int	main(int argc, char **argv, char **env)
{
	t_shell	*shell;
	char	*line;
	char	*prompt;

	(void) argc;
	(void) argv;
	// printbanner();
	shell = init_shell(env);
	ft_signals_control_main();
	while (shell)
	{
		g_signal = 0;
		prompt = ft_print_prompt(shell);
		line = readline(prompt);
		free(prompt);
		if (!line)
			break ;
		ft_handle_line(line, env, shell);
		free(line);
	}
	ft_free_shell(shell);
	if (isatty(STDIN_FILENO))
		ft_printf(YELLOW"\nSEE YOU SOON !\n"RST);
	return (EXIT_SUCCESS);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:00:01 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/18 17:12:02 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*ft_get_val(char *var, t_shell *shell)
{
	t_env	*env;

	env = ft_var_exists(shell->env, var);
	if (!env || !env->data)
		return (NULL);
	return (ft_strdup(env->value));
}

char	*build_new_env(char *var, char *data)
{
	char	*tmp;
	char	*result;

	tmp = ft_strjoin(var, "=");
	if (!tmp)
		return (NULL);
	result = ft_strjoin(tmp, data);
	free(tmp);
	return (result);
}

char	*ft_update_env(char *var, char *data, t_shell *shell)
{
	t_env	*env;
	char	*new_data;

	env = ft_var_exists(shell->env, var);
	if (!env)
	{
		new_data = build_new_env(var, data);
		if (!new_data)
			return (NULL);
		ft_append_env(ft_strdup(new_data), shell);
		return (new_data);
	}
	new_data = build_new_env(var, data);
	if (!new_data)
		return (NULL);
	free(env->data);
	free(env->value);
	free(env->var);
	env->data = new_data;
	env->var = ft_extract_var(new_data);
	env->value = ft_extract_value(new_data);
	return (env->data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 10:17:11 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/25 20:18:12 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_printf_export(t_env *env)
{
	t_env	*env_copy;
	t_env	*tmp;

	env_copy = ft_cread_env_copy(env);
	if (!env_copy)
		return (1);
	ft_sort_env_copy(env_copy);
	tmp = env_copy;
	while (tmp)
	{
		ft_putstr_fd("declare -x ", STDOUT_FILENO);
		ft_putstr_fd(tmp->var, STDOUT_FILENO);
		if (ft_strchr(tmp->data, '='))
		{
			ft_putstr_fd("=\"", STDOUT_FILENO);
			ft_putstr_fd(tmp->value, STDOUT_FILENO);
			ft_putstr_fd("\"", STDOUT_FILENO);
		}
		ft_putstr_fd("\n", STDOUT_FILENO);
		tmp = tmp->next;
	}
	ft_free_env(env_copy);
	return (0);
}

int	ft_concat_env(char *var, char *value, t_env *node)
{
	char	*joined;
	char	*new_data;

	if (!node || !value || !node->value)
		return (1);
	joined = ft_strjoin(node->value, value);
	if (!joined)
		return (1);
	new_data = build_new_env(var, joined);
	free(joined);
	if (!new_data)
		return (1);
	free(node->data);
	free(node->value);
	free(node->var);
	node->data = new_data;
	node->var = ft_extract_var(new_data);
	node->value = ft_extract_value(new_data);
	return (0);
}

static void	ft_update_or_append_env(t_shell *shell, int equal, \
	char *var, char *value)
{
	t_env	*existing;

	existing = ft_var_exists(shell->env, var);
	if (existing)
	{
		if (equal == 1)
			ft_update_env(var, value, shell);
		else if (equal == 2)
			ft_concat_env(var, value, existing);
	}
	else
	{
		if (equal)
			ft_append_env(build_new_env(var, value), shell);
		else
			ft_append_env(ft_strdup(var), shell);
	}
}

static int	ft_export_with_arg(t_shell *shell, char **args)
{
	int		equal;
	char	*var;
	char	*value;

	equal = ft_check_equal(args[1]);
	var = ft_extract_var(args[1]);
	value = ft_extract_value(args[1]);
	if (!var || !value)
	{
		free(var);
		free(value);
		return (1);
	}
	ft_update_or_append_env(shell, equal, var, value);
	free(var);
	free(value);
	return (0);
}

int	ft_export_builtins(t_shell *shell)
{
	if (!shell->cmds->args[1])
		return (ft_printf_export(shell->env));
	if (ft_parsing_export_arg(shell->cmds->args[1]) || \
		(shell->cmds->args[1] && shell->cmds->args[2]))
	{
		ft_export_error_msj(shell->cmds->args[1], \
		"not a valid identifier");
		return (1);
	}
	if (ft_export_with_arg(shell, shell->cmds->args))
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils2.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/14 14:27:43 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/27 15:16:48 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_export_error_msj(char *arg, char *msj)
{
	ft_putstr_fd("minishell: export: ", STDERR_FILENO);
	if (arg)
	{
		ft_putstr_fd(arg, STDERR_FILENO);
		ft_putstr_fd(": ", STDERR_FILENO);
	}
	if (msj)
		ft_putendl_fd(msj, STDERR_FILENO);
}

int	ft_parsing_export_arg(char *arg)
{
	int	i;

	i = 1;
	if (!ft_isalpha(arg[0]) && (arg[0] != '_'))
		return (1);
	while (arg[i] && !(arg[i] == '=' || (arg[i] \
	== '+' && arg[i + 1] == '=')))
	{
		if (!ft_isalpha(arg[i]) && !ft_isdigit(arg[i]) \
	&& !(arg[i] == '_'))
			return (1);
		i++;
	}
	return (0);
}

int	ft_check_equal(char *arg)
{
	int	i;

	i = 0;
	while (arg[i])
	{
		if (arg[i] == '=')
			return (1);
		else if (arg[i] == '+' && arg[i + 1] == '=')
			return (2);
		i++;
	}
	return (0);
}

t_env	*ft_var_exists(t_env *env, char *arg)
{
	char	*var;

	var = ft_extract_var(arg);
	while (env)
	{
		if (ft_strcmp(env->var, var) == 0)
		{
			// free(var);
			return (env);
		}
		env = env->next;
	}

	return (NULL);
}

t_env	*ft_find_env(t_shell *shell, char *var)
{
	t_env	*env;

	env = shell->env;
	while (env)
	{
		if (ft_strcmp(env->var, var) == 0)
			return (env);
		env = env->next;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 17:38:56 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/18 14:38:51 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	ft_exit_error_msj(int exit, char *arg, char *msj)
{
	if (exit)
		ft_putendl_fd("exit", STDERR_FILENO);
	ft_putstr_fd("minishell: exit: ", STDERR_FILENO);
	if (arg)
	{
		ft_putstr_fd(arg, STDERR_FILENO);
		ft_putstr_fd(": ", STDERR_FILENO);
	}
	if (msj)
		ft_putstr_fd(msj, STDERR_FILENO);
}

static int	ft_is_number(char *arg)
{
	int	i;
	int	num;

	i = 0;
	num = 0;
	if (arg[0] == '-' || arg[0] == '+')
		i++;
	while (ft_isdigit(arg[i]))
		i++;
	if (arg[i] == '\0')
		num = 1;
	return (num);
}

static int	ft_check_exit_path(t_cmd *cmd, t_shell *shell)
{
	if (!ft_is_number(cmd->args[1]) && !cmd->args[2])
	{
		ft_exit_error_msj(1, cmd->args[1], "numeric argument required\n");
		ft_free_shell(shell);
		exit (255);
	}
	if (cmd->args[1] && cmd->args[2])
	{
		if (!ft_is_number(cmd->args[1]))
		{
			ft_exit_error_msj(1, cmd->args[1], "numeric argument required\n");
			ft_free_shell(shell);
			exit (255);
		}
		else
		{
			ft_exit_error_msj(0, NULL, "too many arguments\n");
			return (1);
		}
	}
	return (0);
}

static void	ft_exit_valid_path(t_cmd *cmd, t_shell *shell)
{
	long	num;

	num = shell->exit_status;
	if (cmd->args[1])
		num = ft_atol (cmd->args[1]);
	if (num < 0 || num > 255)
		num %= 256;
	ft_putendl_fd("exit", STDOUT_FILENO);
	ft_free_shell(shell);
	exit((unsigned char)num);
}

void	ft_exit_builtins(t_cmd *cmd, t_shell *shell)
{
	int	size;
	int	status;

	status = shell->exit_status;
	if (!cmd->args[1])
	{
		ft_putendl_fd("exit", STDOUT_FILENO);
		ft_free_shell(shell);
		exit(status);
	}
	if (ft_check_exit_path(cmd, shell))
		return ;
	size = ft_strlen(cmd->args[1]);
	if ((cmd->args[1][0] == '-' && (size > 20 || \
	(size == 20 && ft_strcmp(cmd->args[1], "-9223372036854775808") > 0))) \
	|| (cmd->args[1][0] != '-' && (size > 19 || (size == 19 && \
ft_strcmp(cmd->args[1], "9223372036854775807") > 0))))
	{
		ft_exit_error_msj(1, cmd->args[1], "numeric argument required\n");
		ft_free_shell(shell);
		exit(255);
	}
	ft_exit_valid_path(cmd, shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 13:40:32 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/09 17:27:30 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_is_newline(char *str)
{
	int	i;

	if (str[0] != '-')
		return (1);
	i = 1;
	if (str[i] == '\0')
		return (1);
	while (str[i])
	{
		if (str[i] != 'n')
			return (1);
		i++;
	}
	return (0);
}

static int	ft_echo_printf(char **args)
{
	int	i;

	i = 0;
	while (args[i])
	{
		ft_putstr_fd(args[i], 1);
		if (args[i + 1])
			ft_putstr_fd(" ", 1);
		i++;
	}
	return (0);
}

int	ft_echo_builtins(t_cmd *cmd)
{
	int	i;
	int	newline;

	i = 1;
	newline = 1;
	if (!cmd || !cmd->args || !cmd->args[0])
		return (1);
	while (cmd->args[i] && !ft_is_newline(cmd->args[i]))
	{
		newline = 0;
		i++;
	}
	ft_echo_printf(cmd->args + i);
	if (newline)
		ft_putstr_fd("\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 13:52:59 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/05 17:59:28 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_env_builtins(t_cmd *cmd, t_env *env)
{
	(void)cmd;
	while (env)
	{
		if (env->data && ft_strchr(env->data, '='))
			ft_putendl_fd(env->data, 1);
		env = env->next;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/12 11:37:00 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/20 15:47:17 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static t_env	*ft_lstnew_env(t_env *content)
{
	t_env	*cont;

	cont = malloc(sizeof(t_env));
	if (!cont)
		return (NULL);
	cont->data = ft_strdup(content->data);
	if (!cont->data)
	{
		free(cont);
		return (NULL);
	}
	cont->var = ft_extract_var(cont->data);
	cont->value = ft_extract_value(cont->data);
	cont->exporte = content->exporte;
	cont->next = NULL;
	cont->prev = NULL;
	return (cont);
}

static void	ft_lstadd_back_env(t_env **lst, t_env *new)
{
	t_env	*last_node;

	if (!*lst)
		*lst = new;
	else
	{
		last_node = *lst;
		while (last_node->next != NULL)
			last_node = last_node->next;
		last_node->next = new;
		new->prev = last_node;
	}
}

t_env	*ft_cread_env_copy(t_env *env)
{
	t_env	*env_copy;
	t_env	*new_nodo;

	env_copy = NULL;
	new_nodo = NULL;
	while (env)
	{
		new_nodo = ft_lstnew_env(env);
		if (!new_nodo)
		{
			ft_free_env(env_copy);
			return (NULL);
		}
		ft_lstadd_back_env(&env_copy, new_nodo);
		env = env->next;
	}
	return (env_copy);
}

void	ft_swap_env_content(t_env *a, t_env *b)
{
	char	*tmp;
	int		tmp_exporte;

	tmp = a->data;
	a->data = b->data;
	b->data = tmp;
	tmp = a->var;
	a->var = b->var;
	b->var = tmp;
	tmp = a->value;
	a->value = b->value;
	b->value = tmp;
	tmp_exporte = a->exporte;
	a->exporte = b->exporte;
	b->exporte = tmp_exporte;
}

void	ft_sort_env_copy(t_env *head)
{
	t_env	*current;
	int		swap;

	swap = 1;
	while (swap)
	{
		swap = 0;
		current = head;
		while (current && current->next)
		{
			if (ft_strcmp(current->var, current->next->var) > 0)
			{
				ft_swap_env_content(current, current->next);
				swap = 1;
			}
			current = current->next;
		}
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 11:45:47 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/09 17:28:30 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_pwd_builtins(t_cmd *cmd)
{
	char	*rute;

	(void)cmd;
	rute = getcwd(NULL, 0);
	if (!rute)
	{
		ft_putstr_fd("minishell: pwd: getcwd failed\n", STDERR_FILENO);
		return (1);
	}
	ft_putstr_fd(rute, STDOUT_FILENO);
	ft_putstr_fd("\n", STDOUT_FILENO);
	free(rute);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd.c                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 10:57:58 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/15 20:26:25 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_cd_home(t_shell *shell)
{
	char	*home;
	char	*oldpwd;
	char	cwd[PATH_MAX];

	home = ft_get_val("HOME", shell);
	if (!home)
	{
		ft_putstr_fd("minishell: cd: HOME not set\n", STDERR_FILENO);
		return (1);
	}
	oldpwd = ft_get_val("PWD", shell);
	if (chdir(home) == -1)
	{
		perror("minishell: cd");
		free(home);
		free(oldpwd);
		return (1);
	}
	if (oldpwd)
		ft_update_env("OLDPWD", oldpwd, shell);
	if (getcwd(cwd, PATH_MAX))
		ft_update_env("PWD", cwd, shell);
	free(home);
	free(oldpwd);
	return (0);
}

static int	ft_cd_oldpwd2(char *oldpwd, char *pwd, t_shell *shell)
{
	char	cwd[PATH_MAX];

	ft_putstr_fd(oldpwd, STDOUT_FILENO);
	ft_putstr_fd("\n", STDOUT_FILENO);
	if (pwd)
		ft_update_env("OLDPWD", pwd, shell);
	if (getcwd(cwd, PATH_MAX))
		ft_update_env("PWD", cwd, shell);
	free(oldpwd);
	free(pwd);
	return (0);
}

static int	ft_cd_oldpwd(t_shell *shell)
{
	char	*oldpwd;
	char	*pwd;

	oldpwd = ft_get_val("OLDPWD", shell);
	if (!oldpwd)
	{
		ft_putstr_fd("minishell: cd: OLDPWD not set\n", STDERR_FILENO);
		return (1);
	}
	pwd = ft_get_val("PWD", shell);
	if (chdir(oldpwd) == -1)
	{
		perror ("minishell : cd -");
		free(pwd);
		free(oldpwd);
		return (1);
	}
	return (ft_cd_oldpwd2(oldpwd, pwd, shell));
}

int	ft_cd_builtins(t_cmd *cmd, t_shell *shell)
{
	if (cmd->args[1] && cmd->args[2])
	{
		ft_putstr_fd("minishell: cd: too many arguments\n", STDERR_FILENO);
		shell->exit_status = 1;
		return (1);
	}
	if (!cmd->args[1] || ft_strncmp(cmd->args[1], "~", 2) == 0)
		return (ft_cd_home(shell));
	if (ft_strncmp(cmd->args[1], "-", 2) == 0)
		return (ft_cd_oldpwd(shell));
	return (ft_cd_path(cmd->args[1], shell));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/29 12:21:11 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/14 14:20:13 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_is_builtin(char *arg)
{
	if (!ft_strcmp(arg, "echo") || !ft_strcmp(arg, "cd")
		|| !ft_strcmp(arg, "pwd") || !ft_strcmp(arg, "export")
		|| !ft_strcmp(arg, "unset") || !ft_strcmp(arg, "env")
		|| !ft_strcmp(arg, "exit"))
		return (1);
	return (0);
}

int	ft_is_builtin_no_fork(char *arg)
{
	if (!ft_strcmp(arg, "cd") || !ft_strcmp(arg, "export")
		|| !ft_strcmp(arg, "unset") || !ft_strcmp(arg, "exit"))
		return (1);
	return (0);
}

int	ft_no_fork(t_cmd *cmd, t_shell *shell)
{
	if (!(!cmd->next && cmd->args && ft_is_builtin_no_fork(cmd->args[0])))
		return (0);
	ft_exec_builtins(cmd, shell);
	return (1);
}

void	ft_exec_builtins(t_cmd *cmd, t_shell *shell)
{
	if (!ft_strcmp(cmd->args[0], "echo"))
		shell->exit_status = ft_echo_builtins(cmd);
	else if (!ft_strcmp(cmd->args[0], "cd"))
		shell->exit_status = ft_cd_builtins(cmd, shell);
	else if (!ft_strcmp(cmd->args[0], "pwd"))
		shell->exit_status = ft_pwd_builtins(cmd);
	else if (!ft_strcmp(cmd->args[0], "env"))
		shell->exit_status = ft_env_builtins(cmd, shell->env);
	else if (!ft_strcmp(cmd->args[0], "exit"))
		ft_exit_builtins(cmd, shell);
	else if (!ft_strcmp(cmd->args[0], "export"))
		ft_export_builtins(shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cd_path.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/06 14:12:28 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/09 17:29:26 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_check_access(char *arg, char *pwd)
{
	if (access(arg, F_OK) == -1)
	{
		ft_putstr_fd("minishell: cd: ", STDERR_FILENO);
		ft_putstr_fd(arg, STDERR_FILENO);
		ft_putstr_fd(": No such file or directory\n", STDERR_FILENO);
		free(pwd);
		return (1);
	}
	return (0);
}

static int	check_directory(char *arg)
{
	struct stat	info;

	if (stat(arg, &info) == -1)
	{
		perror ("stat");
		return (1);
	}
	if (!S_ISDIR(info.st_mode))
	{
		ft_putstr_fd("minishell: cd: ", STDERR_FILENO);
		ft_putstr_fd(arg, STDERR_FILENO);
		ft_putstr_fd(": Not a directory\n", STDERR_FILENO);
		return (1);
	}
	return (0);
}

int	ft_cd_path(char *arg, t_shell *shell)
{
	char	cwd[PATH_MAX];
	char	*pwd;

	pwd = ft_get_val("PWD", shell);
	if (ft_check_access(arg, pwd))
		return (1);
	if (check_directory(arg))
	{
		free(pwd);
		return (1);
	}
	if (chdir(arg) == -1)
	{
		perror("minishell: cd");
		free(pwd);
		return (1);
	}
	if (pwd)
		ft_update_env("OLDPWD", pwd, shell);
	if (getcwd(cwd, PATH_MAX))
		ft_update_env("PWD", cwd, shell);
	free(pwd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/04 11:21:39 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/07 10:03:07 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_dup_files(t_cmd *cmd)
{
	if (cmd->in < 0 || cmd->out < 0)
		return (0);
	if (cmd->in >= 0 && cmd->in != STDIN_FILENO)
	{
		if (dup2(cmd->in, STDIN_FILENO) < 0)
		{
			perror("dup2 to stdin");
			close(cmd->in);
			if (cmd->out >= 0 && cmd->out != STDOUT_FILENO)
				close(cmd->out);
			return (0);
		}
		close(cmd->in);
	}
	if (cmd->out >= 0 && cmd->out != STDOUT_FILENO)
	{
		if (dup2(cmd->out, STDOUT_FILENO) < 0)
		{
			perror("dup2 to stdout");
			close(cmd->out);
			return (0);
		}
		close(cmd->out);
	}
	return (1);
}

static int	ft_exec(t_cmd *cmd, char **env, t_shell *shell)
{
	if (!cmd->args)
		return (0);
	if (ft_is_builtin(cmd->args[0]))
	{
		ft_exec_builtins(cmd, shell);
		ft_free_shell(shell);
		exit(EXIT_SUCCESS);
	}
	else if (execve(cmd->args[0], cmd->args, env) < 0)
		return (0);
	return (1);
}

static void	ft_close(t_cmd *all_cmd, t_cmd *cmd)
{
	while (all_cmd)
	{
		if (all_cmd != cmd)
		{
			if (all_cmd->in >= 0 && all_cmd->in != STDIN_FILENO)
				close(all_cmd->in);
			if (all_cmd->out >= 0 && all_cmd->out != STDOUT_FILENO)
				close(all_cmd->out);
		}
		all_cmd = all_cmd->next;
	}
}

static void	ft_child_process(t_cmd *cmd, char **env, t_shell *shell)
{
	ft_close(shell->cmds, cmd);
	if (!ft_dup_files(cmd))
	{
		if (cmd->in < 0)
		{
			ft_free_shell(shell);
			exit(EXIT_FD);
		}
		ft_free_shell(shell);
		return ;
	}
	if (!ft_exec(cmd, env, shell))
	{
		ft_free_shell(shell);
		exit(EXIT_CANNOT_EXECUTE);
	}
}

void	ft_process(char **env, t_shell *shell)
{
	pid_t	pid;
	t_cmd	*cmd;

	cmd = shell->cmds;
	while (cmd)
	{
		if (!ft_no_fork(cmd, shell))
		{
			pid = fork();
			if (pid < 0)
				return ;
			if (!pid)
			{
				ft_child_process(cmd, env, shell);
				exit(EXIT_FAILURE);
			}
		}
		cmd = cmd->next;
	}
	ft_free_cmds(shell->cmds);
	shell->cmds = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   readline.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 16:24:29 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/19 16:24:29 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static struct termios   ft_no_raw_and_echo_mode(void)
{
	struct termios  oldt;
	struct termios  newt;

	tcgetattr(STDIN_FILENO, &oldt);
	newt = oldt;
	newt.c_lflag &= ~(ICANON | ECHO);
	tcsetattr(STDIN_FILENO, TCSANOW, &newt);
	return (oldt);
}

static char	*ft_join_to_line(unsigned char seq[4], char *line, t_shell *shell)
{
	char	*new_line;
	char	*malloc_seq;
	int		i;

	malloc_seq = malloc(sizeof(char) * 4);
	if (!malloc_seq)
	{
		if (line)
			free(line);
		ft_error("malloc sequence error", EXIT_MALLOC, shell);
	}
	ft_bzero(malloc_seq, 4);
	i = -1;
	while (seq[++i] && i < 4)
		malloc_seq[i] = seq[i];
	if (line)
	{
		new_line = ft_strjoin(line, malloc_seq);
		free(line);
		free(malloc_seq);
		return (new_line);
	}
	return (malloc_seq);
}

char    *ft_readline(t_shell *shell)
{
	struct termios  oldt;
	unsigned char	seq[4];
	char			*line;
	int				swtch;
	
	line = NULL;
	oldt = ft_no_raw_and_echo_mode();
	ft_bzero(seq, sizeof(seq));
    while (read(STDIN_FILENO, &seq[0], 1) == 1 && seq[0] != '\n')
	{
		swtch = ft_switch_seq(seq, &line, shell);
		if (swtch == -1)
			break;
        if (!swtch)
		{
			line = ft_join_to_line(seq, line, shell);
			ft_printf("%s", seq);
		}	
		ft_bzero(seq, sizeof(seq));
    }
	tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
	ft_printf("\n");
	if (!line && seq[0] == '\n')
		line = ft_strjoin("\n", "");
	return (line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   switch.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/20 09:29:46 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/20 09:29:46 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_manage_arrows(unsigned char seq[4], char **line, t_shell *shell)
{
	char	*prompt;
	char	*new_line;

	if (read(STDIN_FILENO, &seq[1], 1) != 1
		|| read(STDIN_FILENO, &seq[2], 1) != 1)
		return (-1);
	if (seq[1] == '[')
	{
		if (seq[2] == 'A')
			shell->history = shell->history->next;
		else if (seq[2] == 'B')
			shell->history = shell->history->prev;
		else
			return (1);
		new_line = ft_strdup(shell->history->line);
		free(*line);
		*line = new_line;
		printf("\r\033[K");
		prompt = ft_print_prompt(shell);
		ft_printf ("%s%s", prompt, *line);
		free(prompt);
	}
	return (1);
}

static int  ft_backspace(char *line)
{
	int len;

	if (!line)
		return (1);
	len = ft_strlen(line);
	if (len > 0)
	{
		ft_printf("\b \b");
		line[len - 1] = 0;
	}
	return (1);
}

static int  ft_ctrl_D(char **line)
{
	if (!*line)
		return (-1);
	if (!*line[0])
	{
		free(*line);
		*line = NULL;
		return (-1);
	}
	return (1);
}

int	ft_switch_seq(unsigned char seq[4], char **line, t_shell *shell)
{
	if (seq[0] == 0x1b)
		return (ft_manage_arrows(seq, line, shell));
	if (seq[0] == 127)
		return (ft_backspace(*line));
	if (seq[0] == 4)
		return (ft_ctrl_D(line));
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   banner.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/28 07:59:58 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/03 10:31:37 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	printbanner(void)
{
	ft_printf (RED"	███╗   ███╗██╗███╗   ██╗██╗"
		"███████╗██╗  ██╗███████╗██╗     ██╗\n"
		"	████╗ ████║██║████╗  ██║██║██╔════╝"
		"██║  ██║██╔════╝██║     ██║\n"
		"	██╔████╔██║██║██╔██╗ ██║██║"
		"███████╗███████║█████╗  ██║     ██║\n"
		"	██║╚██╔╝██║██║██║╚██╗██║██║"
		"╚════██║██╔══██║██╔══╝  ██║     ██║\n"
		"	██║ ╚═╝ ██║██║██║ ╚████║██║███████║"
		"██║  ██║███████╗███████╗███████╗\n"
		"	╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝╚═╝╚══════╝"
		"╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝\n"
		"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n"RST);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/15 18:22:00 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/27 15:12:41 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*ft_extract_var(char *data)
{
	int		len;
	char	*sep;
	char	*value;

	sep = ft_strchr(data, '=');
	if (!sep)
		return (ft_strdup(data));
	len = sep - data;
	if (len > 0 && data[len -1] == '+')
		len --;
	value = ft_substr(data, 0, len);
	return (value);
}

char	*ft_extract_value(char *data)
{
	char	*sep;
	char	*tmp;
	char	*value;
	int		len;

	sep = ft_strchr(data, '=');
	if (!sep)
		return (ft_strdup(""));
	tmp = sep + 1;
	len = ft_strlen(tmp);
	if (len >= 2 && ((tmp[0] == '"' && tmp[len - 1] == '"') \
	|| (tmp[0] == '\'' && tmp[len - 1] == '\'')))
		value = ft_substr(tmp, 1, len - 2);
	else
		value = ft_strdup(tmp);
	return (value);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 15:42:29 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/18 10:25:34 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_compare(char *var, t_env *current_env, int len)
{
	char	*current_var;
	int		i;

	current_var = current_env->data;
	i = 0;
	while (i < len)
	{
		if (var[i] != current_var[i])
			return (0);
		i++;
	}
	return (1);
}

t_env	*ft_search_env(char *var, t_shell *shell)
{
	int		len;
	t_env	*env;

	len = 0;
	while (var[len])
		len++;
	env = shell->env;
	while (env)
	{
		if (ft_compare(var, env, len))
			return (env);
		env = env->next;
	}
	return (NULL);
}

void	ft_unset_env(t_env *to_delete, t_shell *shell)
{
	if (!shell->env->next)
		shell->env = NULL;
	else
	{
		if (to_delete->prev)
			to_delete->prev->next = to_delete->next;
		if (to_delete->next)
			to_delete->next->prev = to_delete->prev;
	}
	free(to_delete->data);
	free(to_delete->var);
	free(to_delete->value);
	free(to_delete);
}

void	ft_append_env(char *data, t_shell *shell)
{
	t_env	*env;
	t_env	*var_env;

	if (!data)
		ft_error("No data to append in env", EXIT_SYNTAX_ERROR, shell);
	var_env = malloc(sizeof(t_env));
	if (!var_env)
		ft_error("new env var malloc error", EXIT_MALLOC, shell);
	var_env->data = data;
	var_env->var = ft_extract_var(data);
	var_env->value = ft_extract_value(data);
	var_env->exporte = NOT_EXPORTE;
	var_env->next = NULL;
	var_env->prev = NULL;
	if (!shell->env)
	{
		shell->env = var_env;
		return ;
	}
	env = shell->env;
	while (env->next)
		env = env->next;
	var_env->prev = env;
	env->next = var_env;
}

void	ft_init_env(char **env, t_shell *shell)
{
	char	path[PATH_MAX];
	int		i;

	if (!env)
	{
		if (!getcwd(path, PATH_MAX))
			ft_error("Cannot get the path", EXIT_ENV, shell);
		ft_append_env(ft_strjoin("PATH=", path), shell);
		return ;
	}
	i = 0;
	while (env[i])
	{
		ft_append_env(ft_strdup(env[i]), shell);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   history.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 17:24:58 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/09 17:26:51 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static t_hist	*ft_add_first_history(t_hist *new_history, t_shell *shell)
{
	t_hist	*history;

	history = shell->history;
	while (history->prev)
		history = history->prev;
	history->prev = new_history;
	return (history);
}

void	ft_init_history(char *line, t_shell *shell)
{
	t_hist	*history;

	history = malloc(sizeof(t_hist));
	if (!history)
		ft_error("history malloc error", EXIT_MALLOC, shell);
	history->line = line;
	if (shell->history)
		history->next = ft_add_first_history(history, shell);
	else
		history->next = NULL;
	history->prev = NULL;
	shell->history = history;
}

void	ft_free_history(t_hist *history)
{
	t_hist	*next_hist;

	if (!history)
		return ;
	while (history->prev)
		history = history->prev;
	while (history)
	{
		next_hist = history->next;
		free(history->line);
		free(history);
		history = next_hist;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   shell.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 12:13:11 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/09 17:15:40 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_shell	*init_shell(char **env)
{
	t_shell	*shell;

	shell = malloc(sizeof(t_shell));
	if (!shell)
	{
		perror("shell malloc");
		exit(EXIT_MALLOC);
	}
	shell->cmds = NULL;
	shell->history = NULL;
	shell->env = NULL;
	shell->exit_status = EXIT_SUCCESS;
	ft_init_env(env, shell);
	return (shell);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.h                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/01 10:18:42 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/27 15:18:07 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef BUILTINS_H
# define BUILTINS_H

# include "structs.h"
# include "minishell.h"

# define PATH_MAX 4096
# define EXPORTE 1
# define NOT_EXPORTE 0

/*  builtins  */
int		ft_is_builtin(char *arg);
int		ft_is_builtin_no_fork(char *arg);
int		ft_no_fork(t_cmd *cmd, t_shell *shell);
void	ft_exec_builtins(t_cmd *cmd, t_shell *shell);

/*  cd_path  */
int		ft_cd_path(char *arg, t_shell *shell);

/*  cd  */
int		ft_cd_builtins(t_cmd *cmd, t_shell *shell);

/*  echo.c  */
int		ft_echo_builtins(t_cmd *cmd);

/*  env_utils  */
char	*ft_get_val(char *var, t_shell *shell);
char	*build_new_env(char *var, char *data);
char	*ft_update_env(char *var, char *data, t_shell *shell);

/*  env  */
int		ft_env_builtins(t_cmd *cmd, t_env *env);

/*  exit  */
void	ft_exit_builtins(t_cmd *cmd, t_shell *shell);

/*  export_utils  */
t_env	*ft_cread_env_copy(t_env *env);
void	ft_swap_env_content(t_env *a, t_env *b);
void	ft_sort_env_copy(t_env *head);

/*  export_utils2  */
void	ft_export_error_msj(char *arg, char *msj);
int		ft_parsing_export_arg(char *arg);
int		ft_check_equal(char *arg);
t_env	*ft_var_exists(t_env *env, char *arg);
t_env	*ft_find_env(t_shell *shell, char *var);

/*  export_utils3  */

/*  export  */
int		ft_concat_env(char *var, char *value, t_env *node);
int		ft_export_builtins(t_shell *shell);

/*  pwd  */
int		ft_pwd_builtins(t_cmd *cmd);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/03 10:10:14 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/25 20:21:28 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PARSING_H
# define PARSING_H

typedef enum e_token_type
{
	TOKEN_WORD,
	TOKEN_STRING,
	TOKEN_PIPE,
	TOKEN_REDIR_IN,
	TOKEN_REDIR_OUT,
	TOKEN_REDIR_APPEND,
	TOKEN_HEREDOC
}			t_token_type;

typedef struct s_token
{
	t_token_type	type;
	char			*value;
	struct s_token	*next;
}				t_token;

/* * * * * * *
*  readline *
* * * * * * * */

int		ft_switch_seq(unsigned char seq[4], char **line, t_shell *shell);

/* * * * * *
* parser *
* * * * * */

void	ft_parse(char *line, t_shell *shell);
int		ft_open_cmd(t_token	**token, t_cmd *cmd, t_shell *shell);

/* * * * * * *
* tokeniser *
* * * * * * * */

t_token	*ft_tokeniser(char *line, t_shell *shell);
t_token	*ft_sort_token(t_token *token);

/* * * * *
* file *
* * * * * */

int		ft_open_infile(char *filename, t_cmd *cmd);
int		ft_open_outfile(char *filename, t_cmd *cmd, t_token_type type);
void	ft_open_pipe(t_cmd *cmd, t_shell *shell);
void	ft_heredoc(char *limiter, t_cmd *cmd, t_token *token, t_shell *shell);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit_codes.h                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: yel-mens <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 12:23:37 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/02 12:25:05 by yel-mens         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef EXIT_CODES_H
# define EXIT_CODES_H

// Standard exit codes
# define EXIT_SUCCESS         0     // Succès
# define EXIT_FAILURE         1     // Échec générique
# define EXIT_SYNTAX_ERROR    2     // Erreur de syntaxe

// Command-related exit codes (POSIX-compatible)
# define EXIT_CANNOT_EXECUTE 126   // Commande non exécutable (permissions)
# define EXIT_CMD_NOT_FOUND  127   // Commande introuvable
# define EXIT_SIGINT         130   // Ctrl+C
# define EXIT_SIGQUIT        131   // Ctrl+'\'
# define EXIT_SEGFAULT       139   // Segfault (pour debug)
# define EXIT_FATAL          255   // Erreur fatale / valeur hors plage

// Custom internal shell errors
# define EXIT_MALLOC         42    // Erreur d'allocation mémoire
# define EXIT_ENV            43    // Erreur liée aux variables d'environnement
# define EXIT_FD             44    // Erreur de descripteur de fichier
# define EXIT_BUILTIN_ERROR  45    // Erreur dans l'exécution d'un builtin

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   structs.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/02 12:03:15 by yel-mens          #+#    #+#             */
/*   Updated: 2025/05/15 20:19:02 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef STRUCTS_H
# define STRUCTS_H

typedef struct s_cmd
{
	char			**args;
	int				in;
	int				out;
	struct s_cmd	*next;
}	t_cmd;

typedef struct s_env
{
	char			*data;
	char			*var;
	char			*value;
	int				exporte;
	struct s_env	*next;
	struct s_env	*prev;
}	t_env;

typedef struct s_hist
{
	char			*line;
	struct s_hist	*next;
	struct s_hist	*prev;
}	t_hist;

typedef struct s_shell
{
	t_cmd	*cmds;
	t_env	*env;
	t_hist	*history;
	int		exit_status;
}	t_shell;

/* * * *  *
*  shell *
* * * * * */

t_shell	*init_shell(char **env);

/* * * * * * *
*  env _util *
* * * * * * */

char	*ft_extract_value(char *data);
char	*ft_extract_var(char *data);

/* * * * *
*  env *
* * * * */

void	ft_init_env(char **env, t_shell *shell);
t_env	*ft_search_env(char *var, t_shell *shell);
void	ft_append_env(char *data, t_shell *shell);
void	ft_unset_env(t_env *to_delete, t_shell *shell);

/* * * *
* cmd *
* * * * */

t_cmd	*ft_init_cmd(void);

/* * * * * * *
*  history *
* * * * * * **/

void	ft_init_history(char *line, t_shell *shell);

/* * * *  *
*  free *
* * * * * */

void	ft_free_array(char **array);
void	ft_free_env(t_env *env);
void	ft_error(char *msg, int exit_code, t_shell *shell);
void	ft_free_cmds(t_cmd *cmds);
void	ft_free_history(t_hist *history);
void	ft_free_shell(t_shell *shell);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/22 10:44:05 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/27 11:56:19 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SIGNALS_H
# define SIGNALS_H

# include "minishell.h"

// À voir si j’en aurai besoin
typedef enum e_context
{
	CTX_PROMPT,
	CTX_EXEC,
	CTX_HEREDOC
}	t_context;

void	ft_sigint_handler(int signal);
void	ft_signals_control_main(void);
int	ft_check_signal(char *line);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: brturcio <brturcio@student.42angouleme.    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/30 18:47:34 by brturcio          #+#    #+#             */
/*   Updated: 2025/05/27 13:07:29 by brturcio         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include "libft.h"
# include "builtins.h"
# include "structs.h"
# include "exit_codes.h"
# include "parsing.h"
# include "signals.h"
# include <limits.h>
# include <stdio.h>
# include <unistd.h>
# include <fcntl.h>
# include <stdlib.h>
# include <stdio.h>
# include <termios.h>
# include <sys/wait.h>
# include <sys/stat.h>
# include <signal.h>

// À voir si j’en aurai besoin
# include <termios.h>
# include <sys/ioctl.h>
#include <readline/readline.h>
#include <readline/history.h>

# define HGRN	"\e[0;92m"
# define HMAG	"\e[0;95m"

# define BLACK	"\033[0;30m"
# define RED	"\033[0;31m"
# define GREEN	"\033[0;32m"
# define YELLOW	"\033[0;33m"
# define BLUE	"\033[0;34m"
# define PURPLE	"\033[0;35m"
# define CYAN	"\033[0;36m"
# define WHITE	"\033[0;37m"
# define RST	"\033[0m"

# define MAX_LINE_LEN 1024

extern volatile sig_atomic_t	g_signal;

void	printbanner(void);
// void	ft_print_prompt(t_shell *shell);
char	*ft_print_prompt(t_shell *shell);
char	*ft_readline(t_shell *shell);
void	ft_process(char **env, t_shell *shell);

#endif
